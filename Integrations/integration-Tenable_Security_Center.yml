commonfields:
  id: Tenable Security Center
  version: -1
name: Tenable Security Center
display: Tenable Security Center
category: Vulnerability Management
image: data:image/png;base64,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
description: SecurityCenterÂ® consolidates and evaluates vulnerability data across
  your organization, prioritizing security risks and providing a clear view of your
  security posture.
configuration:
- display: Server URL (e.g https://tenablesc.eastus.cloudapp.azure.com)
  name: server
  defaultvalue: ""
  type: 0
  required: true
- display: Username
  name: credentials
  defaultvalue: ""
  type: 9
  required: true
- display: Trust any certificate (unsecure)
  name: unsecure
  defaultvalue: ""
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |
    import time
    import re
    from requests import Request, Session
    import requests
    import json
    import datetime


    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' CONSTANTS '''

    USERNAME = demisto.params()['credentials']['identifier']
    PASSWORD = demisto.params()['credentials']['password']
    VERIFY_SSL = not demisto.params().get('unsecure', False)
    SESSION = None

    def get_server_url():
        url = demisto.params()['server']
        url = re.sub('/[\/]+$/', '', url)
        url = re.sub('\/$', '', url)
        return url


    BASE_URL = get_server_url()
    SERVER_URL = BASE_URL + '/rest'

    def send_request(path, method = 'get', body=None, params=None, headers=None):
        body = body if body is not None else {}
        params = params if params is not None else {}

        url = '{}/{}'.format(SERVER_URL, path)

        headers = headers if headers is not None else get_headers()
        res = SESSION.request(method, url, data=json.dumps(body), params=params, auth=(USERNAME, PASSWORD), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            try:
                error = res.json()
            except:
                raise Exception('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))
            raise Exception('Got an error from Security Center, code: {}, details: {}'.format(error['error_code'], error['error_msg']))
        return res.json()


    def get_headers():
            headers = {}
            headers['Accept'] = 'application/json'
            headers['Content-Type'] = 'application/json'

            return headers


    def send_login_request(login_body):
        path = 'token'
        url = '{}/{}'.format(SERVER_URL, path)

        headers = get_headers()
        res = SESSION.request('post', url, headers=headers, data=json.dumps(login_body), verify=VERIFY_SSL)
        if res.status_code < 200 or res.status_code >= 300:
            raise Exception('Got status code ' + str(res.status_code) + ' with url ' + url + ' with body ' + res.content + ' with headers ' + str(res.headers))

        return res.json()


    def login(user_name, password):
        login_body = { 'username': user_name, 'password': password }
        login_response = send_login_request(login_body)

        if 'response' not in login_response:
            raise Exception('Could not retrieve login token')

        token = login_response['response'].get('token')
        # There might be a case where the API does not return a token because there are too many sessions with the same user.
        # In that case we need to add 'releaseSession = true';
        if not token:
            login_body['releaseSession'] = 'true'
            login_response = send_login_request(login_body)
            if 'response' not in login_response or 'token' not in login_response['response']:
                raise Exception('Could not retrieve login token')
            token = login_response['response']['token']

        return token


    def list_scans_command():
        res = list_scans()
        managable = demisto.args().get('managable').lower()

        if not res or 'response' not in res or not res['response']:
            return 'No scans found'

        scans_arrays = res['response'].get('manageable')
        scans_dicts = []

        if managable == 'false':
            scans_arrays += res['response'].get('usable')
            no_dups = list(set([tuple(s.items()) for s in scans_arrays]))
            scans_dicts = [dict(s) for s in no_dups]
        else:
            scans_dicts = scans_arrays

        if len(scans_dicts) == 0:
            return 'No scans found'

        mapped_scans = [{'Name': s['name'], 'ID': s['id']} for s in scans_dicts]

        headers = [
        'ID',
        'Name'
        ]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable SecurityCenter Scans", mapped_scans, headers, removeNull=True),
            'EntryContext': {
                  'Tenable.Scan(val.ID==obj.ID)': createContext(mapped_scans, removeNull=True)
            }
        }

        return entry

    def list_scans():
        path = 'scan'

        return send_request(path)

    def launch_scan_command():
        scan_id = demisto.args()['scanID']
        target_address = demisto.args().get('diagnosticTarget')
        target_password = demisto.args().get('diagnosticPassword')

        if (target_address and not target_password) or (target_password and not target_address):
            raise ValueError('If a target is provided, both IP/Hostname and the password must be provided')

        res = launch_scan(scan_id, {'address': target_address, 'password': target_password})

        if not res or 'response' not in res or not res['response'] or 'scanResult' not in res['response']:
            return 'Could not retrieve the scan'

        scan_result = res['response']['scanResult']

        headers = [
            'Name',
            'ResultID',
            'OwnerID',
            'JobID',
            'Status'
        ]


        mapped_scan = {
            'Name': scan_result['name'],
            'ResultID': scan_result['id'],
            'OwnerID': scan_result['ownerID'],
            'JobID': scan_result['jobID'],
            'Status': scan_result['status']
        }

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable SecurityCenter Scan", mapped_scan, headers, removeNull=True),
            'EntryContext': {
                  'Nexpose.Scan(val.ID==obj.ID)': createContext(mapped_scan, removeNull=True)
            }
        }

        return entry


    def launch_scan(scan_id, scan_target):
        path = 'scan/' + scan_id + '/launch'
        body = None
        if scan_target:
            body = {
                'diagnosticTarget': scan_target['address'],
                'diagnosticPassword': scan_target['password']
            }

        return send_request(path, 'post', body=body)

    def get_scan_status_command():
        scan_results_ids = argToList(demisto.args()['scanResultsID'])

        scans_results = []
        for scan_results_id in scan_results_ids:
            res = get_scan_results(scan_results_id)
            if not res or 'response' not in res or not res['response']:
                return 'Scan results not found'
            scans_results.append(res['response'])

        headers = [
            'Name',
            'Status',
            'Description'
        ]

        mapped_scans_results = [{'ID': scan_result['id'], 'Name': scan_result['name'],'Status': scan_result['status'], 'Description': scan_result['description']} for scan_result in scans_results]

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Tenable SecurityCenter Scan Status", mapped_scans_results, headers, removeNull=True),
            'EntryContext': {
                  'Tenable.Scan(val.ID==obj.ID)': createContext(mapped_scans_results, removeNull=True)
            }
        }

        return entry


    def get_scan_results(scan_results_id):
        path = 'scanResult/' + scan_results_id

        return send_request(path)

    def get_scan_report_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = get_scan_report(scan_results_id)

        if not res or 'response' not in res or not res['response']:
            return 'Scan results not found'

        scan_results = res['response']

        headers = [
            'Name',
            'Status',
            'Description',
            'ScannedIPs',
            'StartTime',
            'EndTime',
            'Checks',
            'ScannerName',
            'OwnerName',
            'RepositoryName'
        ]

        vuln_headers = [
            'ID',
            'Name',
            'Family',
            'Severity',
            'Total'
        ]

        mapped_results = {
            'ID': scan_results['id'],
            'Name': scan_results['name'],
            'Status': scan_results['status'],
            'Description': scan_results['description'],
            'Status': scan_results['status'],
            'Checks': scan_results['completedChecks'],
            'StartTime': datetime.datetime.utcfromtimestamp(int(scan_results['startTime'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'EndTime': datetime.datetime.utcfromtimestamp(int(scan_results['finishTime'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'ScannedIPs': scan_results['scannedIPs'],
            'OwnerName': scan_results['owner'].get('username'),
            'RepositoryName': scan_results['repository'].get('name')
        }

        hr = tableToMarkdown('Tenable SecurityCenter Scan ' + mapped_results['ID'] + ' Report', mapped_results, headers, removeNull=True)

        vulnerabilites = get_vulnearbilites(scan_results_id)
        if vulnerabilites and len(vulnerabilites) > 0:
            hr += tableToMarkdown("Vulnerabilities", vulnerabilites, vuln_headers, removeNull=True)
            mapped_results['Vulnerability'] = vulnerabilites

        entry = {
            'Type': entryTypes['note'],
            'Contents': res,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                'TenableSC.Scan(val.ID==obj.ID)': createContext(mapped_results, removeNull=True)
            }
        }

        return entry

    def get_scan_report(scan_results_id):
        path = 'scanResult/' + scan_results_id

        params = {
            'fields': 'name,description,status,scannedIPs,progress,startTime,finishTime,completedChecks,owner,repository'
        }

        return send_request(path, params=params)


    def get_vulnearbilites(scan_results_id):
        query = get_query(scan_results_id, 'vulnipdetail')

        if not query or 'response' not in query:
            return 'Could not get vulnerabilites query'

        analysis = get_analysis(query['response']['id'], scan_results_id)

        if not analysis or 'response' not in analysis:
            return 'Could not get vulnerabilites analysis'

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return 'No vulnerabilities found'


        mapped_vulns = []

        for vuln in results:
            mapped_vuln =  {
                'ID': vuln['pluginID'],
                'Name': vuln['name'],
                'Description': vuln['pluginDescription'],
                'Family': vuln['family'].get('name'),
                'Severity': vuln['severity'].get('name'),
                'Total': vuln['total']
            }

            mapped_vulns.append(mapped_vuln)

        sv = [
          'Critical',
          'High',
          'Medium',
          'Low',
          'Info'
        ]

        mapped_vulns.sort(key=lambda r: r['Severity'], cmp=lambda a,b: sv.index(a) - sv.index(b))

        return mapped_vulns


    def get_query(scan_id, tool, query_filters=None):
        path = 'query'

        body = {
            'name': 'scan ' + scan_id + ' query',
            'type': 'vuln',
            'tool': tool,
            'scanID': scan_id
        }

        if query_filters:
            body['filters'] = query_filters

        return send_request(path, method='post', body=body)

    def get_analysis(query_id, scan_results_id):
        path = 'analysis'

        body = {
            'type': 'vuln',
            'query': {
                'id': query_id
            },
            'sourceType': 'individual',
            'scanID': scan_results_id,
            'view': 'all'
        }

        return send_request(path, method='post', body=body)

    def get_vulnerability_command():
        vuln_id = demisto.args()['vulnerabilityID']
        scan_results_id = demisto.args()['scanResultsID']

        vuln_filter = [{
            'filterName': 'pluginID',
            'operator': '=',
            'value': vuln_id
        }]

        query = get_query(scan_results_id, 'vulnipdetail', vuln_filter)

        if not query or 'response' not in query:
            return 'Could not get vulnerability query'

        analysis = get_analysis(query['response']['id'], scan_results_id)

        if not analysis or 'response' not in analysis:
            return 'Could not get vulnerabilites analysis'

        results = analysis['response']['results']

        if not results or len(results) == 0:
            return 'Vulnerability not found in the scan'

        vuln_response = get_vulnerability(vuln_id)

        if not vuln_response or 'response' not in vuln_response:
            return 'Vulnerability not found'

        vuln = vuln_response['response']

        vuln['severity'] = results[0]['severity']
        vuln['hosts'] = results[0]['hosts']

        vuln_hosts = vuln['hosts']
        severity = vuln['severity'].get('name')
        hosts = [{'IP': h['ip'], 'MAC': h['macAddress']} for h in demisto.dt(vuln_hosts, 'iplist')]


        cve = None
        if vuln.get('xrefs'):
            # Extract CVE
            cve_filter = list(filter(lambda x: x.strip().startswith('CVE'), vuln['xrefs'].split(',')))
            if cve_filter and len(cve_filter) > 0:
                cve_str = str(cve_filter[0]).split(":")
                cve = cve_str[1] if len(cve_str) > 1 else None

        mapped_vuln =  {
            'ID': vuln['id'],
            'Name': vuln['name'],
            'Description': vuln['description'],
            'Type': vuln['type'],
            'Severity': severity,
            'Synopsis': vuln['synopsis'],
            'Solution': vuln['solution'],

        }

        vuln_info = {
            'Published': datetime.datetime.utcfromtimestamp(int(vuln['vulnPubDate'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'CPE': vuln['cpe'],
            'CVE': cve
        }

        exploit_info = {
            'ExploitAvailable': vuln['exploitAvailable'],
            'ExploitEase': vuln['exploitEase']
        }

        risk_info = {
            'RiskFactor': vuln['riskFactor'],
            'CVSSBaseScore': vuln['baseScore'],
            'CVSSTemporalScore': vuln['temporalScore'],
            'CVSSVector': vuln['cvssVector']
        }

        plugin_details = {
            'Family': vuln['family'].get('name'),
            'Published': datetime.datetime.utcfromtimestamp(int(vuln['pluginPubDate'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'Modified': datetime.datetime.utcfromtimestamp(int(vuln['pluginModDate'])).strftime('%Y-%m-%dT%H:%M:%SZ'),
            'CheckType': vuln['checkType']
        }

        hr = '## Vulnerability: {} ({})\n'.format(mapped_vuln['Name'], mapped_vuln['ID'])
        hr += '### Synopsis\n{}\n### Description\n{}\n### Solution\n{}\n'.format(mapped_vuln['Synopsis'], mapped_vuln['Description'], mapped_vuln['Solution'])
        hr += tableToMarkdown('Hosts', hosts, removeNull=True)
        hr += tableToMarkdown('Risk Information', risk_info, removeNull=True)
        hr += tableToMarkdown('Exploit Information', exploit_info, removeNull=True)
        hr += tableToMarkdown('Plugin Details', plugin_details, removeNull=True)
        hr += tableToMarkdown('Vulnerability Information', vuln_info, removeNull=True)

        mapped_vuln.update(vuln_info)
        mapped_vuln.update(exploit_info)
        mapped_vuln.update(risk_info)
        mapped_vuln['pluginDetails'] = plugin_details

        scan_result = {
            'ID': scan_results_id,
            'Vulnerability': mapped_vuln,
        }

        return {
            'Type': entryTypes['note'],
            'Contents': vuln_response,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': {
                  'TenableSC.Scan(val.ID==obj.ID)': createContext(scan_result, removeNull=True)
            }
        }

    def get_vulnerability(vuln_id):
        path = 'plugin/' + vuln_id

        params = {
            'fields': 'name,description,family,type,cpe,riskFactor,solution,synopsis,exploitEase,exploitAvailable,cvssVector,baseScore,pluginPubDate,pluginModDate,vulnPubDate,temporalScore,xrefs,checkType'
        }

        return send_request(path, params=params)


    def stop_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'stop')

        if not res:
            return 'Could not stop the scan'

        return 'Scan sucessfully stopped'

    def pause_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'pause')

        if not res:
            return 'Could not pause the scan'

        return 'Scan sucessfully paused'

    def resume_scan_command():
        scan_results_id = demisto.args()['scanResultsID']

        res = change_scan_status(scan_results_id, 'resume')

        if not res:
            return 'Could not resume the scan'

        return 'Scan sucessfully resumed'

    def change_scan_status(scan_results_id, status):
        path = 'scanResult/' + scan_results_id + '/' + status

        return send_request(path, method='post')

    def delete_scan_command():
        scan_id = demisto.args('scanID')

        res = delete_scan(scan_id)

        if not res:
            return 'Could not delete the scan'

        return 'Scan sucessfully deleted'

    def delete_scan(scan_id):
        path = 'scan/' + scan_id

        return send_request(path, method='delete')

    def logout():
        send_request(path='token', method='delete')

    SESSION = Session()
    token = login(USERNAME, PASSWORD)
    SESSION.headers.update({'X-SecurityCenter': str(token)})

    if demisto.command() == 'test-module':
        demisto.results('ok')
    elif demisto.command() == 'tenable-sc-list-scans':
        demisto.results(list_scans_command())
    elif demisto.command() == 'tenable-sc-launch-scan':
        demisto.results(launch_scan_command())
    elif demisto.command() == 'tenable-sc-get-scan-status':
        demisto.results(get_scan_status_command())
    elif demisto.command() == 'tenable-sc-get-scan-report':
        demisto.results(get_scan_report_command())
    elif demisto.command() == 'tenable-sc-get-vulnerability':
        demisto.results(get_vulnerability_command())
    elif demisto.command() == 'tenable-sc-stop-scan':
        demisto.results(stop_scan_command())
    elif demisto.command() == 'tenable-sc-pause-scan':
        demisto.results(pause_scan_command())
    elif demisto.command() == 'tenable-sc-resume-scan':
        demisto.results(resume_scan_command())

    logout()
  type: python
  commands:
  - name: tenable-sc-list-scans
    arguments:
    - name: managable
      description: Whether to return only manageable scans.
      defaultValue: "false"
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.ID
      description: Scan ID
      type: number
    description: Get a list of Tenable SecurityCenter existing scans
  - name: tenable-sc-launch-scan
    arguments:
    - name: scanID
      required: true
      description: Scan ID
    - name: diagnosticTarget
      description: Valid IP/Hostname of a specific target to scan. Must be provided
        with diagnosticPassword.
    - name: diagnosticPassword
      description: Non empty string password
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.ResultID
      description: Scan Result ID
      type: string
    - contextPath: TenableSC.Scan.OwnerID
      description: Scan owner ID
      type: string
    - contextPath: TenableSC.JobID
      description: Job ID
      type: string
    - contextPath: TenableSC.Scan.Status
      description: Scan status
      type: string
    description: Launch an existing scan from Tenable SecurityCenter
  - name: tenable-sc-get-scan-status
    arguments:
    - name: scanResultsID
      required: true
      description: Scan Results ID
      isArray: true
    outputs:
    - contextPath: TenableSC.Scan.Status
      description: Scan status
      type: string
    - contextPath: TenableSC.Scan.Name
      description: Scan Name
      type: string
    - contextPath: TenableSC.Scan.Description
      description: Scan description
    description: Get the status of a specific scan in Tenable SecurityCenter
  - name: tenable-sc-get-scan-report
    arguments:
    - name: scanResultsID
      required: true
      description: Scan Results ID
    outputs:
    - contextPath: TenableSC.Scan.Name
      description: Scan name
      type: string
    - contextPath: TenableSC.Scan.Status
      description: Scan status
      type: string
    - contextPath: TenableSC.Scan.ScannedIPs
      description: Number of scanned IPs
      type: number
    - contextPath: TenableSC.Scan.StartTime
      description: Scan start time
      type: date
    - contextPath: TenableSC.Scan.EndTime
      description: Scan end time
      type: date
    - contextPath: TenableSC.Scan.Checks
      description: Scan completed checks
      type: number
    - contextPath: TenableSC.Scan.ScannerName
      description: Scanner engine name
      type: string
    - contextPath: TenableSC.Scan.OwnerName
      description: Scan owner username
      type: string
    - contextPath: TenableSC.Scan.RepositoryName
      description: Scan repository name
      type: string
    - contextPath: TenableSC.Scan.Description
      description: Scan description
    description: Get a report with a Tenable SecurityCenter scan results
  - name: tenable-sc-download-report
    arguments:
    - name: scanID
      required: true
      description: Scan ID
    description: Download a report with a given Tenable SecurityCenter scan results
  - name: tenable-sc-stop-scan
    arguments:
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: Stop a scan in Tenable SecurityCenter
  - name: tenable-sc-pause-scan
    arguments:
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: Pause a scan in Tenable SecurityCenter
  - name: tenable-sc-resume-scan
    arguments:
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: Resume a scan in Tenable SecurityCenter
  - name: tenable-sc-create-scan
    arguments:
    - name: name
      required: true
      description: Scan name
    - name: typeID
      required: true
      description: Scan type (plugin or policy) ID
    - name: description
      description: Scan description
    - name: repositoryID
      required: true
      description: Repository ID for the scan
    - name: zoneID
      description: Zone ID for the scan (default is all zones)
    - name: schedule
      auto: PREDEFINED
      predefined:
      - dependent
      - ical
      - never
      - rollover
      - now
      description: Schedule time for the scan
      defaultValue: now
    - name: assetID
      description: Asset IDs to scan (Separated by comma)
    - name: scanningVirtualHosts
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Decide if the scan includes virtual hosts
      defaultValue: "false"
    - name: ipList
      description: IP list to scan
    outputs:
    - contextPath: TenableSC.Scan.ID
      description: Scan ID
      type: string
    - contextPath: TenableSC.Scan.Creator.ID
      description: Scan's creator ID
      type: string
    - contextPath: TenableSC.Scan.Name
      description: Scan Name
      type: string
    - contextPath: TenableSC.Scan.Type
      description: Scan type
      type: string
    - contextPath: TenableSC.Scan.Policy.ID
      description: Policy ID
      type: string
    - contextPath: TenableSC.Scan.Plugin.ID
      description: Plugin ID
      type: string
    - contextPath: TenableSC.Scan.Repository.ID
      description: Scan's repository ID
      type: string
    - contextPath: TenableSC.Scan.CreatedTime
      description: Scan's created time
      type: date
    - contextPath: TenableSC.Scan.Scedule.Type
      description: Scan's schedule type
      type: string
    - contextPath: TenableSC.Scan.Owner.Name
      description: Owner's Username
      type: string
    description: Create a scan on Tenable Security Center
  - name: tenable-sc-delete-scan
    arguments:
    - name: scanID
      required: true
      description: Scan ID
    description: Delete a scan in Tenable SecurityCenter
  - name: tenalbe-sc-list-assets
    arguments:
    - name: usable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Filter results by usable flag
      defaultValue: "true"
    - name: manageable
      auto: PREDEFINED
      predefined:
      - "true"
      - "false"
      description: Filter results by manageable flag
      defaultValue: "true"
    outputs:
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: string
    - contextPath: TenableSC.Asset.Name
      description: Asset Name
      type: string
    description: Get a list of Tenable SecurityCenter Assets
  - name: tenable-sc-create-asset
    arguments:
    - name: name
      required: true
      description: Asset Name
    - name: description
      description: Asset description
    - name: ownerID
      description: default is the Session User ID
    - name: tags
      description: Tag the Asset
    - name: data
      description: An ip, a list or a range of ip addresses
    outputs:
    - contextPath: TenableSC.Asset.Name
      description: Asset Name
      type: string
    - contextPath: TenableSC.Asset.ID
      description: Asset ID
      type: string
    - contextPath: TenableSC.Asset.owner,ID
      description: Asset's owner ID
      type: string
    - contextPath: TenableSC.Asset.Tag
      description: Asset's related tags
      type: string
    description: Create an Asset in Tenable Security Center. The Asset can be a single
      ip address, a list or a range of ip addresses.
  - name: tenable-sc-get-vulnerability
    arguments:
    - name: vulnerabilityID
      required: true
      description: Vulnerability ID
    - name: scanResultsID
      required: true
      description: Scan results ID
    description: 'Get details about a given vulnerability from a given Tenable SecurityCenter
      scan '
  runonce: false
releaseNotes: "-"